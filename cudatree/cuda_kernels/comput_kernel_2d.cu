#include <stdio.h>
#include <math.h>
#include <stdint.h>
#include <assert.h>

#define THREADS_PER_BLOCK %d
#define MAX_NUM_LABELS %d
#define SAMPLE_DATA_TYPE %s
#define LABEL_DATA_TYPE %s
#define COUNT_DATA_TYPE %s
#define IDX_DATA_TYPE %s
#define MAX_BLOCK_PER_FEATURE %d
#define DEBUG %d

#include "common_func.cu"

__global__ void compute(IDX_DATA_TYPE *sorted_indices,
                        SAMPLE_DATA_TYPE *samples, 
                        LABEL_DATA_TYPE *labels,
                        float *impurity_2d, 
                        COUNT_DATA_TYPE *label_total_2d,
                        COUNT_DATA_TYPE *split, 
                        IDX_DATA_TYPE *subset_indices,
                        int n_range,
                        int n_samples, 
                        int stride){
  /* 
    Compute and find minimum gini score for each range of each random generated feature.
    Inputs: 
      - sorte_indices : sorted indices.
      - samples : samples.
      - labels : labels.
      - label_total_2d : label_total for each range of each feature generated by scan_reduce kernel.
      - subset_indices : random generated a subset of features.
      - n_range : we divide the samples into seperate ranges, the number of samples per range.
      - n_samples : number of samples this internal node has.
      - stride : the stride for sorted indices and samples.
    
    Outputs:
      - impurity_2d : the minimum impurity score for each range of each feature.
      - split : the split index which produces the minimum gini score.
  */
  
  uint16_t tidx = threadIdx.x; 
  uint16_t bidx = blockIdx.x;
  uint16_t bidy = blockIdx.y;
  uint16_t step = blockDim.x - 1;

  uint32_t offset = subset_indices[bidx] * stride;
  float reg_imp_right = 2.0;
  float reg_imp_left = 2.0;
  COUNT_DATA_TYPE reg_min_split = 0;

  __shared__ float shared_count[MAX_NUM_LABELS];
  __shared__ LABEL_DATA_TYPE shared_labels[THREADS_PER_BLOCK];
  __shared__ float shared_count_total[MAX_NUM_LABELS];
  __shared__ SAMPLE_DATA_TYPE shared_samples[THREADS_PER_BLOCK];
  
  uint32_t cur_offset = bidx * (MAX_BLOCK_PER_FEATURE + 1) * MAX_NUM_LABELS + bidy * MAX_NUM_LABELS;
  uint32_t last_offset = int(ceil(float(n_samples) / n_range)) * MAX_NUM_LABELS;

  for(uint16_t i = tidx; i < MAX_NUM_LABELS; i += blockDim.x){   
      shared_count[i] = label_total_2d[cur_offset + i];
      shared_count_total[i] = label_total_2d[last_offset + i];
  }
  
  IDX_DATA_TYPE stop_pos = ((bidy + 1) * n_range + 1 < n_samples)? (bidy + 1) * n_range + 1 : n_samples;

  for(IDX_DATA_TYPE i = bidy * n_range + tidx; i < stop_pos; i += step){ 
    IDX_DATA_TYPE idx = sorted_indices[offset + i];
    shared_labels[tidx] = labels[idx]; 
    shared_samples[tidx] = samples[offset + idx];

    __syncthreads();
     
    if(tidx == 0){
      IDX_DATA_TYPE end_pos = (i + step < stop_pos)? step : stop_pos - i - 1;
      
        for(IDX_DATA_TYPE t = 0; t < end_pos; ++t){
          #if DEBUG == 1
          assert(shared_labels[t] >= 0 && shared_labels[t] < MAX_NUM_LABELS);
          #endif

          shared_count[shared_labels[t]]++;
                    
          if(shared_samples[t] == shared_samples[t + 1])
            continue;
          
          float imp_left = calc_imp_left(shared_count, i + 1 + t) * (i + t + 1) / n_samples;
          float imp_right = calc_imp_right(shared_count, shared_count_total, n_samples - i - 1 - t) *
            (n_samples - i - 1 - t) / n_samples;
          
          #if DEBUG == 1
          assert(imp_left >= 0.0 && imp_left <= 1.0);
          assert(imp_right >= 0.0 && imp_right <= 1.0);
          #endif

          if(imp_left + imp_right < reg_imp_right + reg_imp_left){
            reg_imp_left = imp_left;
            reg_imp_right = imp_right;
            reg_min_split = i + t;

            #if DEBUG == 1
            assert(reg_min_split < n_samples);
            #endif
          }  
        }
    }    
    __syncthreads();
  }
    
  if(tidx == 0){
    impurity_2d[bidx * MAX_BLOCK_PER_FEATURE * 2 + 2 * bidy] = reg_imp_left;
    impurity_2d[bidx * MAX_BLOCK_PER_FEATURE * 2 + 2 * bidy + 1] = reg_imp_right;
    split[bidx * MAX_BLOCK_PER_FEATURE + bidy] = reg_min_split;
    #if DEBUG == 1
    assert(reg_imp_left == 2.0 || (reg_imp_left >= 0.0 && reg_imp_left <= 1.0));
    assert(reg_imp_right == 2.0 || (reg_imp_right >= 0.0 && reg_imp_right <= 1.0));
    #endif
  }
}
